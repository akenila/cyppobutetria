import os
import json
from moviepy.editor import VideoFileClip
from datetime import datetime
import shutil
import re
import time
import random
import string
import pyperclip
import pyautogui
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
import os
import time
import pyautogui
import requests
import subprocess

# Chạy đoạn code này để khôi phục project từ backup
import os
import shutil

# Đường dẫn đến thư mục project của CapCut
capcut_path = os.getenv("LOCALAPPDATA") + r"\CapCut"
projects_path = capcut_path + r"\User Data\Projects\com.lveditor.draft"

# Đường dẫn đến thư mục backup
backup_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "project_backup")

if os.path.exists(backup_folder):
    # Kiểm tra xem có project nào trong backup không
    backup_projects = os.listdir(backup_folder)
    if backup_projects:
        print(f"Tìm thấy {len(backup_projects)} project trong backup, đang khôi phục...")
        
        # Di chuyển từng project từ backup về thư mục gốc
        for project in backup_projects:
            backup_path = os.path.join(backup_folder, project)
            project_path = os.path.join(projects_path, project)
            
            try:
                # Xóa project gốc nếu đã tồn tại (tránh conflict)
                if os.path.exists(project_path):
                    shutil.rmtree(project_path)
                    
                # Di chuyển project từ backup về
                shutil.move(backup_path, project_path)
                print(f"Đã khôi phục: {project}")
            except Exception as e:
                print(f"Lỗi khi khôi phục {project}: {str(e)}")

        print("Hoàn tất khôi phục project!")
    else:
        print("Không tìm thấy project nào trong thư mục backup!")
else:
    print(f"Không tìm thấy thư mục backup tại: {backup_folder}")

# Global variables for process control
stop_requested = False
current_process = None


def export_selected_projects(status_var, selected_projects, result_folder_var=None):
    if not selected_projects:
        status_var.set("No projects selected for export")
        return
        
    # Get projects path
    _, projects_path = get_projects_from_path()
    if not projects_path:
        status_var.set("Projects path not found")
        return
        
    # Create backup folder if it doesn't exist
    backup_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "project_backup")
    if not os.path.exists(backup_folder):
        os.makedirs(backup_folder)
        status_var.set(f"Created backup folder: {backup_folder}")

    
    try:
        # Move all projects to backup folder first
        status_var.set("Moving all projects to backup folder...")
        all_projects = [p for p in os.listdir(projects_path) 
                       if p not in ['.recycle_bin', 'root_meta_info.json']]
        
        for project in all_projects:
            project_path = os.path.join(projects_path, project)
            backup_path = os.path.join(backup_folder, project)
            
            # Skip if project already in backup
            if os.path.exists(backup_path):
                continue
                
            # Move project to backup
            if os.path.exists(project_path):
                # Đảm bảo thư mục đích không tồn tại trước khi di chuyển
                if os.path.exists(backup_path):
                    shutil.rmtree(backup_path)
                
                try:
                    # Dùng copy_tree rồi xóa nguồn thay vì move trực tiếp
                    shutil.copytree(project_path, backup_path)
                    shutil.rmtree(project_path)
                    status_var.set(f"{status_var.get()}\nMoved: {project} to backup")
                except Exception as e:
                    status_var.set(f"{status_var.get()}\nError moving {project}: {str(e)}")
        print(f"Moved {len(all_projects)} projects to backup")
        status_var.set(f"Moved {len(all_projects)} projects to backup")
        
        # Process each selected project
        processed = 0
        for project in selected_projects:
            if stop_requested:
                status_var.set("Process stopped")
                break
            print(f"Processing project: {project}")
            status_var.set(f"{status_var.get()}\nProcessing project: {project}")
            
            # Move the project from backup to main folder
            backup_path = os.path.join(backup_folder, project)
            project_path = os.path.join(projects_path, project)
            
            if os.path.exists(backup_path):
                shutil.move(backup_path, project_path)
                status_var.set(f"{status_var.get()}\nMoved {project} to main folder")
                
                # Simulate exporting video (placeholder for your actual code)
                result_folder = result_folder_var.get()
                export_video(status_var, project, result_folder)

                time.sleep(5)  # Simulate export time
                
                # Move the project back to backup after export
                if os.path.exists(project_path):
                    shutil.move(project_path, backup_path)
                    status_var.set(f"{status_var.get()}\nMoved {project} back to backup")
                
                processed += 1
            else:
                status_var.set(f"{status_var.get()}\nProject not found in backup: {project}")
        
        # After all exports, move all projects back to main folder
        status_var.set(f"{status_var.get()}\nMoving all projects back to main folder...")
        backup_projects = os.listdir(backup_folder)
        
        for project in backup_projects:
            backup_path = os.path.join(backup_folder, project)
            project_path = os.path.join(projects_path, project)
            
            # Move project back to main folder
            if os.path.exists(backup_path):
                shutil.move(backup_path, project_path)
        
        status_var.set(f"{status_var.get()}\nCompleted: {processed} projects exported")
        
    except Exception as e:
        print(f"Error during export: {str(e)}")
        status_var.set(f"Error during export: {str(e)}")

def export_video(status_var, project, result_folder=None):
    """Export video from a project"""
    
    status_var.set(f"{status_var.get()}\nExporting video for {project}...")
    print(f"Exporting video for {project}...")
    
    try:
        # Bước 1: Mở CapCut
        status_var.set(f"{status_var.get()}\nĐang mở CapCut...")
        capcut_path = os.path.expandvars(r"%LOCALAPPDATA%\CapCut\Apps\CapCut.exe")
        if not os.path.exists(capcut_path):
            capcut_path = r"C:\Program Files\CapCut\CapCut.exe"
        
        if not os.path.exists(capcut_path):
            status_var.set(f"{status_var.get()}\nKhông tìm thấy CapCut!")
            return False
            
        subprocess.Popen(capcut_path)
        time.sleep(5)  # Chờ CapCut khởi động
        
        # Bước 2: Tải ảnh từ URL và xác định vị trí
        status_var.set(f"{status_var.get()}\nĐang tải ảnh tham chiếu...")
        image_url = "https://raw.githubusercontent.com/akenila/cyppobutetria/refs/heads/main/project.png"  # Thay URL thực tế vào đây
        
        try:
            # Tải ảnh từ URL
            response = requests.get(image_url)
            if response.status_code == 200:
                timestamp = int(time.time())
                random_str = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
                reference_image = f"temp_image_{timestamp}_{random_str}.png"
                with open(reference_image, 'wb') as f:
                    f.write(response.content)
        
                
                # Tìm ảnh trên màn hình
                status_var.set(f"{status_var.get()}\nĐang tìm ảnh tham chiếu trên màn hình...")
                start_time = time.time()
                location = None
                
                while time.time() - start_time < 30:  # Timeout 30 giây
                    try:
                        location = pyautogui.locateCenterOnScreen(reference_image, confidence=0.7)
                        if location:
                            break
                    except Exception as e:
                        status_var.set(f"{status_var.get()}\nLỗi khi tìm ảnh: {str(e)}")
                    time.sleep(1)
                
                # Xóa file tạm
                try:
                    os.remove(reference_image)
                except:
                    pass
                
                if not location:
                    status_var.set(f"{status_var.get()}\nKhông tìm thấy ảnh tham chiếu trên màn hình")
                    return False
                
                # Bước 3: Di chuyển xuống 50px và click
                click_x = location.x
                click_y = location.y + 70
                status_var.set(f"{status_var.get()}\nClick vị trí ({click_x}, {click_y})")
                pyautogui.click(click_x, click_y)
                time.sleep(5)
                
                # Bước 4: Nhấn Ctrl+E để xuất
                status_var.set(f"{status_var.get()}\nNhấn Ctrl+E để xuất video...")
                pyautogui.hotkey('ctrl', 'e')
                time.sleep(2)
                pyautogui.press('enter')  # Nhấn Enter để xác nhận xuất
                time.sleep(2)  # Chờ quá trình xuất bắt đầu
                # Bước 4.1: Tải ảnh xác nhận thứ hai và kiểm tra
                status_var.set(f"{status_var.get()}\nĐang tải ảnh xác nhận thứ hai...")
                confirm_image_url = "https://raw.githubusercontent.com/akenila/cyppobutetria/refs/heads/main/checking.png"  # Thay bằng URL ảnh xác nhận thực tế

                try:
                    # Tải ảnh từ URL
                    confirm_response = requests.get(confirm_image_url)
                    if confirm_response.status_code == 200:
                        confirm_timestamp = int(time.time())
                        confirm_random_str = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
                        confirm_reference_image = f"confirm_image_{confirm_timestamp}_{confirm_random_str}.png"
                        
                        with open(confirm_reference_image, 'wb') as f:
                            f.write(confirm_response.content)
                        
                        # Tìm ảnh trên màn hình với timeout ngắn (3 giây)
                        status_var.set(f"{status_var.get()}\nĐang tìm ảnh xác nhận...")
                        confirm_start_time = time.time()
                        confirm_location = None
                        
                        while time.time() - confirm_start_time < 2:  # Timeout 3 giây
                            try:
                                confirm_location = pyautogui.locateCenterOnScreen(confirm_reference_image, confidence=0.7)
                                if confirm_location:
                                    break
                            except Exception as e:
                                pass
                            time.sleep(0.5)
                        
                        # Xử lý nếu tìm thấy
                        if confirm_location:
                            status_var.set(f"{status_var.get()}\nTìm thấy ảnh xác nhận, nhấn vào nó...")
                            pyautogui.click(confirm_location.x, confirm_location.y)
                            time.sleep(1)
                        
                        # Xóa file tạm
                        try:
                            os.remove(confirm_reference_image)
                        except:
                            pass
                except Exception as e:
                    status_var.set(f"{status_var.get()}\nLỗi khi xử lý ảnh xác nhận: {str(e)}")
                
                # Bước 5: Theo dõi file mp4 được tải về
                if not result_folder:
                    result_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "Result")
                if not os.path.exists(result_folder):
                    os.makedirs(result_folder)
                print(f"Result folder: {result_folder}")
                status_var.set(f"{status_var.get()}\nĐang theo dõi file xuất trong {result_folder}...")
                
                # Lấy danh sách file ban đầu
                initial_files = {f.lower(): os.path.getmtime(os.path.join(result_folder, f)) 
                              for f in os.listdir(result_folder) if f.lower().endswith('.mp4')}
                
                export_complete = False
                start_time = time.time()
                found_file = None
                last_size = -1
                
                while time.time() - start_time < 300:  # Timeout 5 phút
                    current_files = {f.lower(): os.path.getmtime(os.path.join(result_folder, f)) 
                                  for f in os.listdir(result_folder) if f.lower().endswith('.mp4')}
                    
                    # Tìm file mới nhất
                    new_files = {f: t for f, t in current_files.items() if f not in initial_files or current_files[f] > initial_files.get(f, 0)}
                    
                    if new_files:
                        newest_file = max(new_files.items(), key=lambda x: x[1])[0]
                        file_path = os.path.join(result_folder, newest_file)
                        current_size = os.path.getsize(file_path)
                        
                        if file_path == found_file:
                            if current_size == last_size:  # Kích thước không đổi -> xuất xong
                                status_var.set(f"{status_var.get()}\nFile đã xuất xong: {newest_file}")
                                export_complete = True
                                break
                            else:
                                print(f"File {newest_file} size changed: {current_size} bytes")

                        
                        found_file = file_path
                        last_size = current_size
                        status_var.set(f"{status_var.get()}\nĐang theo dõi: {newest_file} ({current_size} bytes)")
                    
                    time.sleep(2)
                
                # Bước 6: Đóng CapCut khi hoàn thành
                status_var.set(f"{status_var.get()}\nĐang đóng CapCut...")
                os.system("taskkill /f /im CapCut.exe")
                
                if export_complete:
                    status_var.set(f"{status_var.get()}\nXuất video thành công: {os.path.basename(found_file)}")
                    return True
                else:
                    status_var.set(f"{status_var.get()}\nXuất video thất bại hoặc hết thời gian chờ")
                    return False
            else:
                status_var.set(f"{status_var.get()}\nKhông thể tải ảnh: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            status_var.set(f"{status_var.get()}\nLỗi khi xử lý ảnh: {str(e)}")
            return False
            
    except Exception as e:
        status_var.set(f"{status_var.get()}\nLỗi khi xuất video: {str(e)}")
        return False
def create_project_selection_window(parent, status_var, result_folder_var):
    """Create a window with checkboxes to select projects for export"""
    projects, _ = get_projects_from_path()
    if not projects:
        messagebox.showinfo("Info", "No projects found")
        return
    
    # Create a new window
    selection_window = tk.Toplevel(parent)
    selection_window.title("Select Projects to Export")
    selection_window.geometry("500x500")
    
    # Create a frame with scrollbar
    frame = ttk.Frame(selection_window)
    frame.pack(fill="both", expand=True, padx=10, pady=10)
    
    canvas = tk.Canvas(frame)
    scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
    scrollable_frame = ttk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    # Create checkboxes for each project
    project_vars = {}
    
    # Add "Select All" checkbox
    select_all_var = tk.BooleanVar(value=False)
    
    def toggle_all():
        """Toggle all checkboxes based on select all checkbox"""
        for var in project_vars.values():
            var.set(select_all_var.get())
    
    select_all_cb = ttk.Checkbutton(
        scrollable_frame, 
        text="Select All",
        variable=select_all_var,
        command=toggle_all
    )
    select_all_cb.grid(row=0, column=0, sticky="w", padx=5, pady=5)
    
    # Add project checkboxes
    for i, project in enumerate(projects, 1):
        var = tk.BooleanVar(value=False)
        project_vars[project] = var
        
        cb = ttk.Checkbutton(
            scrollable_frame,
            text=project,
            variable=var
        )
        cb.grid(row=i, column=0, sticky="w", padx=5, pady=2)
    
    # Add export button
    def start_export():
        """Start exporting selected projects"""
        selected = [project for project, var in project_vars.items() if var.get()]
        
        if not selected:
            messagebox.showinfo("Info", "No projects selected")
            return
            
        selection_window.destroy()
        
        # Start export process in a thread
        global current_process, stop_requested
        stop_requested = False
        print(f"Starting export for {len(selected)} projects: {', '.join(selected)}")
        
        status_var.set(f"Starting export for {len(selected)} projects...")
        
        current_process = threading.Thread(
            target=export_selected_projects,
            args=(status_var, selected, result_folder_var)
        )
        current_process.daemon = True
        current_process.start()
    
    ttk.Button(
        selection_window,
        text="Export Selected Projects",
        command=start_export
    ).pack(pady=10)
    
    ttk.Button(
        selection_window,
        text="Cancel",
        command=selection_window.destroy
    ).pack(pady=5)

def get_projects_from_path():
    """Get projects from the CapCut directory"""
    capcut_path = os.getenv("LOCALAPPDATA") + r"\CapCut"
    projects_path = capcut_path + r"\User Data\Projects\com.lveditor.draft"
    
    if not os.path.exists(projects_path):
        print(f"Error: Projects path not found at {projects_path}")
        return [], ""
    
    # Get all projects except special folders
    all_projects = [p for p in os.listdir(projects_path) 
                    if p not in ['.recycle_bin', 'root_meta_info.json']]
    
    print(f"Found {len(all_projects)} projects in {projects_path}")
    
    return all_projects, projects_path

def select_folder(folder_var):
    """Open folder selection dialog and update the folder path variable"""
    folder_path = filedialog.askdirectory(title="Select Video Folder")
    if folder_path:
        folder_var.set(folder_path)

def validate_input_format(input_text):
    """Validate if input follows the key:value format for each line"""
    if not input_text.strip():
        return True  # Empty input is valid
        
    lines = input_text.strip().split('\n')
    for line in lines:
        if not ':' in line:
            return False
    return True

def save_settings(folder_var, result_folder_var, text_widget, status_var):
    """Save current settings to a file"""
    try:
        input_text = text_widget.get('1.0', tk.END).strip()
        
        # Validate input format
        if not validate_input_format(input_text):
            status_var.set("Error: Input must follow 'key:value' format on each line")
            messagebox.showerror("Format Error", "Input must follow 'key:value' format on each line.")
            return
        
        # Create settings dictionary with folder path and input text
        settings = {
            'folder_path': folder_var.get(),
            'result_folder_path': result_folder_var.get(),
            'input_text': input_text
        }
        
        # Save to JSON file
        with open('capcut_settings.json', 'w', encoding='utf-8') as f:
            json.dump(settings, f, ensure_ascii=False, indent=4)
        
        status_var.set("Settings saved successfully")
    except Exception as e:
        status_var.set(f"Error saving settings: {str(e)}")
        messagebox.showerror("Error", f"Failed to save settings: {str(e)}")

def load_settings(folder_var, result_folder_var, text_widget):
    """Load settings from file if it exists"""
    try:
        if os.path.exists('capcut_settings.json'):
            with open('capcut_settings.json', 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
            # Load folder path if it exists in settings
            if 'folder_path' in settings:
                folder_var.set(settings.get('folder_path', ''))
            
            # Load result folder path if it exists
            if 'result_folder_path' in settings:
                result_folder_var.set(settings.get('result_folder_path', ''))
            
            # Load input text if it exists in settings
            if 'input_text' in settings:
                text_widget.delete('1.0', tk.END)
                text_widget.insert('1.0', settings.get('input_text', ''))
            
            return True
        return False
    except Exception as e:
        print(f"Error loading settings: {str(e)}")
        return False

def copy_effect_with_render(status_var, folder_path=None, input_text=None, result_folder_var=None):
    """Copy effect with rendering"""
    projects, projects_path = get_projects_from_path()
    if not projects:
        status_var.set("No projects found")
        return
    
    if not folder_path:
        status_var.set("No folder path specified")
        return
        
    if not input_text:
        status_var.set("No input text specified")
        return
    
    # Create backup folder if it doesn't exist
    backup_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "project_backup")
    if not os.path.exists(backup_folder):
        os.makedirs(backup_folder)
        status_var.set(f"Created backup folder: {backup_folder}")
        
    status_var.set(f"Copying effect with rendering... Searching videos in: {folder_path}")
    
    # Parse key:value pairs from input text
    pairs = {}
    for line in input_text.strip().split('\n'):
        if ':' in line:
            key, value = line.split(':', 1)
            pairs[key.strip()] = value.strip()
    
    if not pairs:
        status_var.set("No valid key:value pairs found in input")
        return
        
    # Get list of video files in the specified folder
    video_files = []
    if os.path.exists(folder_path):
        video_files = [f for f in os.listdir(folder_path) 
                      if f.lower().endswith(('.mp4', '.mov', '.avi'))]
    
    if not video_files:
        status_var.set(f"No video files found in {folder_path}")
        return
    
    # Move all projects to backup folder first
    status_var.set("Moving all projects to backup folder...")
    all_projects = [p for p in os.listdir(projects_path) 
                   if p not in ['.recycle_bin', 'root_meta_info.json']]
    
    # First, backup all projects
    for project in all_projects:
        project_path = os.path.join(projects_path, project)
        backup_path = os.path.join(backup_folder, project)
        
        # Skip if project already in backup
        if os.path.exists(backup_path):
            continue
            
        # Move project to backup
        if os.path.exists(project_path):
            # Đảm bảo thư mục đích không tồn tại trước khi di chuyển
            if os.path.exists(backup_path):
                shutil.rmtree(backup_path)
            
            try:
                # Dùng copy_tree rồi xóa nguồn thay vì move trực tiếp
                shutil.copytree(project_path, backup_path)
                shutil.rmtree(project_path)
                status_var.set(f"{status_var.get()}\nMoved: {project} to backup")
            except Exception as e:
                status_var.set(f"{status_var.get()}\nError moving {project}: {str(e)}")
    status_var.set(f"Moved {len(all_projects)} projects to backup")
    
    processed = 0
    status_var.set(f"Found {len(video_files)} videos and {len(pairs)} key:value pairs to process")
    
    # Process each key:value pair
    for key, value in pairs.items():
        if stop_requested:
            status_var.set("Process stopped")
            break
            
        # Find videos with key in filename
        matching_videos = [v for v in video_files if key.lower() in v.lower()]
        
        # Find project with value name
        matching_projects = [p for p in projects if value.lower() in p.lower()]
        
        if not matching_videos:
            status_var.set(f"{status_var.get()}\nNo videos found with '{key}' in filename")
            continue
            
        if not matching_projects:
            status_var.set(f"{status_var.get()}\nNo projects found with name '{value}'")
            continue
        
        # Use the first matching video and project
        video_path = os.path.join(folder_path, matching_videos[0])
        project_name = matching_projects[0]
        
        try:
            # Move the project from backup to main folder
            backup_path = os.path.join(backup_folder, project_name)
            project_folder_path = os.path.join(projects_path, project_name)
            
            if os.path.exists(backup_path):
                shutil.move(backup_path, project_folder_path)
                status_var.set(f"{status_var.get()}\nMoved {project_name} to main folder")
            
            # Get video information
            status_var.set(f"{status_var.get()}\nProcessing: '{key}' → '{value}'")
            video_info = get_video_info(video_path)
            if not video_info:
                continue
                
            # Load project JSON
            project_path = os.path.join(projects_path, project_name, "draft_content.json")
            if not os.path.exists(project_path):
                status_var.set(f"{status_var.get()}\nProject file not found: {project_path}")
                continue
                
            with open(project_path, 'r', encoding='utf-8') as f:
                project_data = json.load(f)
                
            # Update project with video info
            duration = video_info["duration"]
            width = video_info["width"]
            height = video_info["height"]
            
            # Update project data with new video properties
            project_data["canvas_config"]["width"] = width
            project_data["canvas_config"]["height"] = height
            project_data["duration"] = duration
            project_data["materials"]["videos"][0]["duration"] = duration
            project_data["materials"]["videos"][0]["path"] = video_path
            project_data["materials"]["videos"][0]["width"] = width
            project_data["materials"]["videos"][0]["height"] = height
            project_data["materials"]["videos"][0]["name"] = os.path.basename(video_path)
            project_data["materials"]["videos"][0]["material_name"] = os.path.basename(video_path)
            
            # Update segments duration
            project_data["tracks"][0]["segments"][0]["source_timerange"]["duration"] = duration
            for track in project_data["tracks"]:
                if track["segments"] and len(track["segments"]) > 0:
                    track["segments"][0]["target_timerange"]["duration"] = duration
            
            # Save updated project
            with open(project_path, 'w', encoding='utf-8') as f:
                json.dump(project_data, f, indent=4, ensure_ascii=False)
                
            status_var.set(f"{status_var.get()}\nApplied effects to {project_name} with video {os.path.basename(video_path)}")
            
            # Render the video
            result_folder = result_folder_var.get() if result_folder_var else None
            export_video(status_var, project_name, result_folder)
            
            # Move project back to backup after export
            if os.path.exists(project_folder_path):
                if os.path.exists(backup_path):
                    shutil.rmtree(backup_path)
                shutil.move(project_folder_path, backup_path)
                status_var.set(f"{status_var.get()}\nMoved {project_name} back to backup")
            
            processed += 1
            
        except Exception as e:
            status_var.set(f"{status_var.get()}\nError processing {key}:{value} - {str(e)}")
    
    # After all exports, move all projects back to main folder
    status_var.set(f"{status_var.get()}\nMoving all projects back to main folder...")
    backup_projects = os.listdir(backup_folder)
    
    for project in backup_projects:
        backup_path = os.path.join(backup_folder, project)
        project_path = os.path.join(projects_path, project)
        
        # Move project back to main folder
        if os.path.exists(backup_path):
            if os.path.exists(project_path):
                shutil.rmtree(project_path)
            shutil.move(backup_path, project_path)
    
    status_var.set(f"{status_var.get()}\nCompleted: {processed} projects processed with rendering")
def copy_effect_only(status_var, folder_path=None, input_text=None):
    """Copy effect without rendering"""
    projects, projects_path = get_projects_from_path()
    if not projects:
        status_var.set("No projects found")
        return
    
    if not folder_path:
        status_var.set("No folder path specified")
        return
        
    if not input_text:
        status_var.set("No input text specified")
        return
        
    status_var.set(f"Copying effect only... Searching videos in: {folder_path}")
    
    # Parse key:value pairs from input text
    pairs = {}
    for line in input_text.strip().split('\n'):
        if ':' in line:
            key, value = line.split(':', 1)
            pairs[key.strip()] = value.strip()
    
    if not pairs:
        status_var.set("No valid key:value pairs found in input")
        return
        
    # Get list of video files in the specified folder
    video_files = []
    if os.path.exists(folder_path):
        video_files = [f for f in os.listdir(folder_path) 
                      if f.lower().endswith(('.mp4', '.mov', '.avi'))]
    
    if not video_files:
        status_var.set(f"No video files found in {folder_path}")
        return
    
    processed = 0
    status_var.set(f"Found {len(video_files)} videos and {len(pairs)} key:value pairs to process")
    
    # Process each key:value pair
    for key, value in pairs.items():
        if stop_requested:
            status_var.set("Process stopped")
            return
            
        # Find videos with key in filename
        matching_videos = [v for v in video_files if key.lower() in v.lower()]
        
        # Find project with value name
        matching_projects = [p for p in projects if value.lower() in p.lower()]
        
        if not matching_videos:
            status_var.set(f"{status_var.get()}\nNo videos found with '{key}' in filename")
            continue
            
        if not matching_projects:
            status_var.set(f"{status_var.get()}\nNo projects found with name '{value}'")
            continue
        
        # Use the first matching video and project
        video_path = os.path.join(folder_path, matching_videos[0])
        project_name = matching_projects[0]
        
        try:
            # Get video information
            status_var.set(f"{status_var.get()}\nProcessing: '{key}' → '{value}'")
            video_info = get_video_info(video_path)
            if not video_info:
                continue
                
            # Load project JSON
            project_path = os.path.join(projects_path, project_name, "draft_content.json")
            if not os.path.exists(project_path):
                status_var.set(f"{status_var.get()}\nProject file not found: {project_path}")
                continue
                
            with open(project_path, 'r', encoding='utf-8') as f:
                project_data = json.load(f)
                
            # Update project with video info (similar to coppy.py)
            duration = video_info["duration"]
            width = video_info["width"]
            height = video_info["height"]
            
            # Update project data with new video properties
            project_data["canvas_config"]["width"] = width
            project_data["canvas_config"]["height"] = height
            project_data["duration"] = duration
            project_data["materials"]["videos"][0]["duration"] = duration
            project_data["materials"]["videos"][0]["path"] = video_path
            project_data["materials"]["videos"][0]["width"] = width
            project_data["materials"]["videos"][0]["height"] = height
            project_data["materials"]["videos"][0]["name"] = os.path.basename(video_path)
            project_data["materials"]["videos"][0]["material_name"] = os.path.basename(video_path)
            
            # Update segments duration
            project_data["tracks"][0]["segments"][0]["source_timerange"]["duration"] = duration
            for track in project_data["tracks"]:
                if track["segments"] and len(track["segments"]) > 0:
                    track["segments"][0]["target_timerange"]["duration"] = duration
            
            # Save updated project
            with open(project_path, 'w', encoding='utf-8') as f:
                json.dump(project_data, f, indent=4, ensure_ascii=False)
                
            processed += 1
            status_var.set(f"{status_var.get()}\nApplied effects to {project_name} with video {os.path.basename(video_path)}")
            
        except Exception as e:
            status_var.set(f"{status_var.get()}\nError processing {key}:{value} - {str(e)}")
            
    status_var.set(f"{status_var.get()}\nCompleted: {processed} projects processed without rendering")

# Add the video info function from coppy.py
def get_video_info(mp4_path):
    """Get video information similar to coppy.py"""
    if not os.path.exists(mp4_path):
        print(f"Error: File '{mp4_path}' doesn't exist")
        return None
    
    try:
        clip = VideoFileClip(mp4_path)
        seconds = clip.duration
        duration = int(seconds * 1000000)
        width, height = clip.size
        return {
            "width": width,
            "height": height,
            "duration": duration,
        }
    
    except Exception as e:
        print(f"Error processing video file: {e}")
        return None


def start_process(option, status_var, folder_var, text_widget, result_folder_var=None):
    global stop_requested, current_process
    
    # Reset stop flag
    stop_requested = False
    
    # Check if a process is already running
    if current_process and current_process.is_alive():
        messagebox.showwarning("Warning", "A process is already running!")
        return
    
    # Get folder path and input text
    folder_path = folder_var.get()
    input_text = text_widget.get('1.0', tk.END).strip()
    
    # Update status
    status_var.set(f"Starting option {option}...")
    
    # Create and start the appropriate thread based on the selected option
    if option == 1:
        current_process = threading.Thread(
            target=copy_effect_with_render, 
            args=(status_var, folder_path, input_text, result_folder_var)
        )
    elif option == 2:
        current_process = threading.Thread(
            target=copy_effect_only, 
            args=(status_var, folder_path, input_text)
        )
        
    current_process.daemon = True
    current_process.start()

def stop_process(status_var):
    global stop_requested
    stop_requested = True
    status_var.set("Stopping process...")

def create_gui():
    # Create the main window
    root = tk.Tk()
    root.title("Coppy Attribute Tool")
    root.geometry("750x500")  # Wider and shorter window
    
    # Create main frame with two columns
    main_frame = ttk.Frame(root)
    main_frame.pack(fill="both", expand=True, padx=5, pady=5)
    
    # Left column for input controls
    left_column = ttk.Frame(main_frame)
    left_column.pack(side="left", fill="both", expand=True, padx=2, pady=2)
    
    # Right column for status and output
    right_column = ttk.Frame(main_frame)
    right_column.pack(side="right", fill="both", expand=True, padx=2, pady=2)
    
    # 1. Folder selection frame (left column)
    folder_frame = ttk.LabelFrame(left_column, text="Video Folder")
    folder_frame.pack(padx=5, pady=5, fill="x")
    
    folder_var = tk.StringVar()
    folder_entry = ttk.Entry(folder_frame, textvariable=folder_var)
    folder_entry.pack(side="left", padx=2, pady=2, fill="x", expand=True)
    
    browse_button = ttk.Button(
        folder_frame,
        text="Browse...",
        command=lambda: select_folder(folder_var)
    )
    browse_button.pack(side="right", padx=2, pady=2)
    
    # Thêm Result Folder frame
    result_folder_frame = ttk.LabelFrame(left_column, text="Result Folder")
    result_folder_frame.pack(padx=5, pady=5, fill="x")
    
    result_folder_var = tk.StringVar()
    result_folder_entry = ttk.Entry(result_folder_frame, textvariable=result_folder_var)
    result_folder_entry.pack(side="left", padx=2, pady=2, fill="x", expand=True)
    
    result_browse_button = ttk.Button(
        result_folder_frame,
        text="Browse...",
        command=lambda: select_folder(result_folder_var)
    )
    result_browse_button.pack(side="right", padx=2, pady=2)
    
    
    # 2. Input text frame (left column)
    input_frame = ttk.LabelFrame(left_column, text="Key:Value Pairs")
    input_frame.pack(padx=5, pady=5, fill="both", expand=True)
    
    # Text widget for multi-line support
    text_widget = tk.Text(input_frame, height=8, width=40)
    text_widget.pack(side="left", padx=2, pady=2, fill="both", expand=True)
    
    # Add example placeholder text
    placeholder_text = "example:value\nkey2:value2"
    text_widget.insert('1.0', placeholder_text)
    
    # Function to clear placeholder on first click
    def clear_placeholder(event):
        if text_widget.get('1.0', 'end-1c') == placeholder_text:
            text_widget.delete('1.0', tk.END)
        text_widget.unbind('<Button-1>', click_binding)
    
    click_binding = text_widget.bind('<Button-1>', clear_placeholder)
    
    # Add scrollbar for text widget
    text_scrollbar = ttk.Scrollbar(input_frame, command=text_widget.yview)
    text_scrollbar.pack(side="right", fill="y")
    text_widget.config(yscrollcommand=text_scrollbar.set)
    
    # 3. Options frame (left column)
    options_frame = ttk.LabelFrame(left_column, text="Options")
    options_frame.pack(padx=5, pady=5, fill="x")
    
    # Create variable to store the selected option
    selected_option = tk.IntVar(value=1)
    
    # Create radio buttons in a more compact layout
    radio_frame = ttk.Frame(options_frame)
    radio_frame.pack(fill="x", padx=2, pady=2)
    
    ttk.Radiobutton(
        radio_frame, 
        text="Copy with render", 
        variable=selected_option, 
        value=1
    ).pack(side="left", padx=5)
    
    ttk.Radiobutton(
        radio_frame, 
        text="Copy only", 
        variable=selected_option, 
        value=2
    ).pack(side="left", padx=5)
    
    
    # 4. Action buttons (left column)
    action_frame = ttk.Frame(left_column)
    action_frame.pack(padx=5, pady=5, fill="x")
    
    start_button = ttk.Button(
        action_frame, 
        text="Start", 
        command=lambda: start_process(selected_option.get(), status_var, folder_var, text_widget, result_folder_var)
    )
    start_button.pack(side="left", padx=2, expand=True, fill="x")
    
    stop_button = ttk.Button(
        action_frame, 
        text="Stop", 
        command=lambda: stop_process(status_var)
    )
    stop_button.pack(side="left", padx=2, expand=True, fill="x")
    
    save_button = ttk.Button(
        action_frame,
        text="Save",
        command=lambda: save_settings(folder_var, result_folder_var, text_widget, status_var)
    )
    save_button.pack(side="left", padx=2, expand=True, fill="x")
    
    export_button = ttk.Button(
        action_frame,
        text="Export Projects",
        command=lambda: create_project_selection_window(root, status_var, result_folder_var)
    )
    export_button.pack(side="left", padx=2, expand=True, fill="x")
    # Thêm vào action_frame trong hàm create_gui()

    restore_button = ttk.Button(
        action_frame,
        text="Khôi phục Project",
        command=lambda: restore_projects_from_backup(status_var)
    )
    restore_button.pack(side="left", padx=2, expand=True, fill="x")

    # Thêm hàm này vào chương trình
    def restore_projects_from_backup(status_var):
        """Khôi phục project từ thư mục backup về thư mục gốc"""
        try:
            _, projects_path = get_projects_from_path()
            if not projects_path:
                status_var.set("Không tìm thấy đường dẫn project")
                return
                
            backup_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), "project_backup")
            if not os.path.exists(backup_folder):
                status_var.set("Không tìm thấy thư mục backup")
                return
                
            backup_projects = os.listdir(backup_folder)
            if not backup_projects:
                status_var.set("Không có project nào trong thư mục backup")
                return
                
            status_var.set(f"Đang khôi phục {len(backup_projects)} project từ backup...")
            
            for project in backup_projects:
                backup_path = os.path.join(backup_folder, project)
                project_path = os.path.join(projects_path, project)
                
                # Move project back to main folder
                if os.path.exists(backup_path):
                    if os.path.exists(project_path):
                        shutil.rmtree(project_path)
                    shutil.move(backup_path, project_path)
                    status_var.set(f"{status_var.get()}\nĐã khôi phục: {project}")
            
            status_var.set(f"{status_var.get()}\nHoàn tất khôi phục {len(backup_projects)} project!")
        except Exception as e:
            status_var.set(f"Lỗi khi khôi phục project: {str(e)}")
    
    # 5. Status area (right column, takes entire right side)
    status_frame = ttk.LabelFrame(right_column, text="Status")
    status_frame.pack(padx=5, pady=5, fill="both", expand=True)
    
    status_var = tk.StringVar(value="Ready")
    status_text = tk.Text(status_frame, wrap="word")
    status_text.pack(side="left", fill="both", expand=True, padx=2, pady=2)
    
    status_scrollbar = ttk.Scrollbar(status_frame, command=status_text.yview)
    status_scrollbar.pack(side="right", fill="y")
    status_text.config(yscrollcommand=status_scrollbar.set)
    
    # Custom setter for status_var to update Text widget
    def set_status(value):
        status_text.delete(1.0, tk.END)
        status_text.insert(tk.END, value)
        status_text.see(tk.END)  # Auto-scroll to the end
    
    status_var.set = set_status
    set_status("Ready")
    
    # Load settings if available
    load_settings(folder_var, result_folder_var, text_widget)
    
    return root, status_var, folder_var, result_folder_var, text_widget
# Main entry point
if __name__ == "__main__":
    root, *_ = create_gui()
    root.mainloop()
